fullf.m and fulljacobian.m are the RHS and RHS Jacobian for the test problem. These can easily be swapped out with whatever we like.

initIntModel contains all of the settings relevant to experimentation, except choice of interval: Intergration interval, model RHS and Jacobian, number of subintervals, integration tolerances, initial point. The tolerances specified are used for all integrations, as well as for the corresponding adjoint and TLM tolerances. model.stateestimate contains the starting point of the integration (used in forming the scaling matrices for the cost function). Since this information is necessary for use in the cost function (and gradient, Hessian) calculations, it's stored in a model object and passed around in the main file.

timeParallelIntegrationBrusselator contains everything important. It has wrappers for forward, adjoint, TLM applications in fwdmodel, adjointmodel, tlmmodel. Integrators are specified here. costfcn returns the cost function evaluation and gradient. Linvtrans and Linv perform applications of the L^{-1}, L^{-T} matrices taken at a given point to a specified matrix. fullHessian forms the full block tridiagonal GN Hessian matrix. At the top are a number of "test blocks" that can be block commented or uncommented. I have one for performing the GN iterations with the full block Hessian, one for performing the GN iterations with L^{-1}, L^{-T} applications, one for performing the optimization with only first-order information and MATLAB's built-in optimizer (LBFGS with line search by default). I also have a finite difference routine I used for verifying gradients.
